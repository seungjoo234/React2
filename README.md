# React2

# 202030229 임승주

## 10월 11일 강의 내용

### Page Project Layout -\_app

- \_app.jsx는 서버에 요청할 때 가장 먼저 실행되는 컴포넌트다.
- 페이지에 적용할 공통 레이아웃을 선언하는 곳임
- 기본 코드는 다음과 같다

```jsx
import "@/styles/globals.css";

export default function App({ Component, pageProps }) {
  return <Component {...pageProps} />;
}
```

- Global CSS는 이곳에 추가됨
- props 중 Component는 서버에 요청한 페이지임

### Page Project Layout -\_document

- \_document.jsx는 \_app.jsx 다음에 실행됨
- 각 페이지에서 공통적으로 사용될 html, head, body 안에 들어갈 내용을 선언함
- onClick 같은 이벤트나 CSS는 이 곳에 선언하지 않음
- 기본 코드는 다음과 같음

```jsx
import { Html, Head, Main, NextScript } from "next/document";

export default function Document() {
  return (
    <Html lang="en">
      <Head />
      <body>
        <Main />
        <NextScript />
      </body>
    </Html>
  );
}
```

- 다음은 수정한 예

```jsx
import { Html, Head, Main, NextScript } from "next/document";

export default function Document() {
  return (
    <Html lang="ko">
      <Head>
      {/* 사용자 정의 메타 태그 */}
      <meta name="description" content="커스텀 설명입니다.">

      {/* 외부 스크립트 추가 */}
      <script src="..."></script>
      </Head>
      <body>
        <Main />
        <NextScript />
      </body>
    </Html>
  );
}
```

### Page Project Layout -\_layout.jsx

- layout.jsx는 app 디렉토리 아래에 위치함
- layout.jsx는 Page Project에서 사용하던 \_app.jsx와 \_document.jsx를 대체함
- 이 파일은 삭제해도 프로젝트를 실행하면 자동으로 다시 생겨남
- 프로젝트를 생성할 때 생성된 기본 코드는 다음과 같음

```jsx
export const metadata = {
  title: "Next.js",
  description: "Generated by Next.js",
};

export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body>{children}</body>
    </html>
  );
}
```

### Page Project Layout - meta data

- metadata에서 모든 페이지에 적용할 meta data를 선언할 수 있습니다.
- title의 경우에는 각 페이지에 맞게 작성하는 것이 SEO에 좋음
- 추가하지 않은 페이지는 layout.jsx에서 정의한 title이 적용됨

```jsx
export const metadata = {
  title: "Hello, Next.js!",
};
```

- 만일 공통되는 title과 함께 각 페이지의 title을 추가 하고 싶은 경우에는 layout.jsx의 title을 다음과 같이 추가한다

```jsx
export const metadata = {
  title: {
    default: "Next.js!",
    template: "%s | Next.js",
  },
  description: "Generated by Next.js",
};
```

- 각 페이지에 적용된 title이 없으면 default값이 적용
- 각 페이지에 적용된 title이 있으면 template값이 적용
- %s에 각 페이지에 title이 삽입되며, 위치는 바꿔도 됨

### Page Project Layout - RootLayout

- Children prop은 각각의 page.jsx를 받아 옴
- html 태그에 옵션을 추가하거나 수정할 수 있음. lang="ko"
- 공통 레이아웃은 body 태그에 추가하면 됨
- 이 때 children prop을 삭제하지 않도록 주의

```jsx
export const metadata = {
  title: "Next.js",
  description: "Generated by Next.js",
};

export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body>{children}</body>
    </html>
  );
}
```

### Page Project Layout - Link component

- /componts/Navibar.jsx 파일을 만든 다음 코드를 추가한다

```jsx
import Link from "next/link";

export default function NavBar() {
  return (
    <nav>
      <Link href="/">Home</Link>
      <Link href="/about">About</Link>
      <Link href="/foo">Foo</Link>
      <Link href="/blog">Blog</Link>
    </nav>
  );
}
```

### Link vs. a vs. router.push

- a tag는 html 동기식으로 전체가 reload 되기 때문에, 외부 링크를 할 때 사용됨
- 일반적으로 내부 링크 이동시에는 사용하지 않는 것이 좋음
- router.push는 빌드 후, 이동할 주소가 html 상에 노출되지 않기 때문에 SEO에 취약함
- Link 컴포넌트는 빌드 후, a tag로 자동 변환됨
- a tag의 장점인 SEO 최적화, prefetch 가능, 우 클릭 기능들을 가짐
- 내부 페이지로의 이동할 때 이 방식을 사용해야 SPA 방식으로 전체 html중 필요한 부분만 비동기식으로 리렌더링 된다
- 따라서 특별한 경우가 아니면 Link 컴포넌트 사용을 권장함

### 1. Image component - local

- 정적 자원 중 이미지 파일은 SEO에 많은 영향을 미친다.
- 다운로드 시간이 많이 걸리고, 렌더링 후에 레이아웃이 변경되는 등 UX에 영향을 미침
- 이것을 누적 레이아웃 이동(CLS: Cumulative Layout Shift)이라고 함
- Image 컴포넌트를 사용하면 CLS문제를 해결함
- lazy loading: 이미지 로드 시점을 필요할 때까지 지연시키는 기술
- 이미지 사이즈 최적화로 사이즈를 1/10이하로 줄여줌
- Placeholder를 제공함
- WebP와 같은 최신 이미지 포맷 및 최신 포맷을 지원하지 않는 브라우저를 위해 png나 jpeg와 같은 예전 이미지 포맷도 제공함
- Pixabay나 Unplash와 같은 외부 이미지 서비스로 이미지를 제공할 수 있음
- 정적 자원은 기본적으로 public 디렉토리에 저장함
- 정적 자원은 번들링 이후에도 변하지 않기 때문
- 여러 종류의 정적 자원을 사용할 경우 public의 root에 각각 디렉토리를 만들어 사용함
- 이미지를 불러오는 방법은 직접 불러오는 방법과 import하는 방법 2가지가 있음
- 직접 불러올 때 경로는 /images/[이미지 이름.확장자] 로 하면 됨

```jsx
import Image from "next/image";

export default function About() {
  return (
    <div>
      <h1>About</h1>
      <p>This is the about page</p>
      <Image src="/images/person.jpg" alt="person" width={300} height={500} />
      <Image src="/images/woman.jpg" alt="woman" width={300} height={500} />
    </div>
  );
}
```

- Import하는 방법은 다음 소스처럼 이미지를 import한 후에 이름만 사용하면 됨
-

## 9월 25일 강의 내용

### 3-1. 라우팅 시스템

- React의 React Router, Reach Router 등은 클라이언트 라우팅만 구현할 수 있다.
- Next는 파일시스템 기반 페이지와 라우팅을 함
- 페이지는 /pages 디렉토리 안의 _.js, _.jsx, _.ts, _.tsx 파일에서 export한 React 컴포넌트다.
- 만알 컨텐츠를 분리해야 한다면?
  - /pages 아래 디렉토리를 만들고 라우팅 규칙을 만들면 됨
  - /pages 디렉토리 내부에는 계층적 구조로 라우팅 규칙을 만들 수 있다.
  - /pages/posts 안에 index.js와 [slug].js를 만들어 jsx를 반환함
  - /pages/posts/ 디렉토리 내에 Index.js만 간단하게 만들면 localhost:3000/posts로 접속이 가능
  - 다만 동적인 라우팅 규칙을 만들려면 [slug].js 파일리 필요
  - [slug].js는 매개 변수로 사용되며 주소창에서 입력하는 값을 모두 받을 수 있음
  - 동적 하우팅 규칙을 중첩할 수도 있음
  - 접근 경로를 ~posts/[date]/[slug]와 같이 만들 수 있음
  - [date] 디렉토리를 만들고 그 안에 [slug].js 파일을 저장하면 됨
  - [date]나 [slug]는 어떤 값이든 가질 수 있다.
  - 실제 앱에서는 경로 매개변수에 따라 서로 다른 동적 페이지를 렌더링하게 됨

## 9월 11일 강의 내용

### Transpile은 어떻게 동작하나

- Babel은 ECMAScript와 같은 자바스크립트 최신 버전이나, Typescript를 이전 버전의 코드로 변환시켜 주는 Transpile 도구다.
- 개발자가 작성한 코드 -> Parse -> Transform -> Generate -> 이전 버전의 코드
- Babel의 parser는 자바스크립트를 컴퓨터가 이해할 수 있는 코드 구조인 Abstract Syntax Tree(AST)로 변환해 주는 역할을 수행
- Babel의 traverse모듈은 전체 트리 상태(AST)를 유지하며 노드 교체, 제거, 추가를 담당
- 마지막 generator가 수정된 AST를 일반 코드로 변환해 주게 됨
- SWC도 Babel과 같은 자바스크립트 트랜스 컴파일러다.
- Next 12 이후 부터 Babel에서 SWC로 교체 됨
- SWC는 Rust로 작성되어 있어 Babel에 비해서 속도가 훨씬 빠름

### SWC를 프로젝트에 적용하려면

- 새로운 프로젝트에 적용하는 것은 다음 명령으로 프로젝트를 생성하면 바로 사용 가능  
  $ npx create-next-app@latest  
  or  
  $ npx create-next-app@12
- Next 12 이전 버전의 프로젝트에 적용하려면 다음과 같이 업그레이드 해줘야 함  
  $ npm install next@12  
  그리고 Babel을 설정했다면 설정 파일 (.Babelrc 또는 babel.config.js)을 삭제해 줌

### 렌더링 전략

- 렌더링 전략이란 웹 페이지 또는 웹 애플리케이션을 웹 브라우저에 제공하는 방법을 의미함
- 정적인 페이지 제작에는 Gatsby를 추천
- 서버 사이드 렌더링 전략을 원한다면 다른 프레임워크를 검토
- 그런데 Next.js에서는 이 모든 방법을 완전히 새로운 수준으로 제공
- 어떤 페이지는 빌드 시점에 정적으로 생성하고, 어떤 페이지는 실행 시점에 동적으로 생성할지 쉽게 정할 수 있음
- 또한 특정 페이지에 대한 요펑이 있을 때마다 페이지를 다시 생성할 수도 있음
- 그리고 반드시 클라이언트에서 렌더링해야 할 컴포넌트고 지정할 수 있음

### 서버 사이드 렌더링(SSR)

- 생소할 수도 있지만 웹 페이지를 제공하는 가장 흔한 방법임
- APM을 이용하는 일반적인 웹 페이지 생성이라 보면 됨
- 여기에 자바스크립트 코드가 적재되면 동적으로 페이지 내용을 렌더링함
- Next.js도 이와 같이 동적으로 페이지를 렌더링할 수 있음
- 그리고 여기에 스크립트 코드를 집어 넣어서 나중에 웹 페이지를 동적으로 처리할 수도 있는데 이를 하이드레이션이라고 함
- 서버 사이드 렌더링 -> 자바스키립트가 하이드레이션된 페이지를 전송 -> 클라이언트에서 DOM위에 각 스크립트 코드를 하이드레이션 페이지 새로 고침 없이 사용자와 웹 페이지간 상호 작용을 가능하게 함
- 리액트 라이드레이션 덕분에 이 상태에서 웹 앱은 싱글 페이지 애플리케이션(SPA) 처럼 작동할 수 있음
- CSR과 SSR의 장점을 모두 가지는 것
- 특정 렌더링 전략만 사용한다고 가정하면 SSR이 CSR에 비해 여러가지 장점이 있음

- [SSR의 장점]
  - 더 안전한 웹 애플리케이션
  - 더 뛰어난 웹 사이트 호환성
  - 더 뛰어난 SEO

### SSR이 최적의 렌더링 전략이 아닌 경우

- 클라이언트가 페이지를 요청할 때마다 페이지를 다시 렌더링할 수 있는 서버가 필요함
- 다른 방식에 비해 SSR이 더 많은 자원을 소모하고, 더 많은 부하를 보이며 유지 보수 비용도 증가함
- 페이지에 대한 요청을 처리하는 시간이 길어짐
- 페이지가 외부 API 또는 데이터 소스에 접근해야 한다면, 해당 페이지를 렌더링할 때마다 이를 다시 요청해야 함
- 페이지 간의 이동은 CSR에 비해 느림
- 중요한 것은 Next.js가 기본적으로 빌드 시점에 정적으로 페이지를 만든다는 것임
- 페이지에서 외부 API를 호출하거나 데이터베이스에 접근하는 등 동적 작업을 해야 한다면 해당하는 함수를 페이지에 export해야 함

### 클라이언트 사이드 렌더링(CSR)

- React 앱을 실행하면 렌더링 시작전에 빈 화면이 한동안 유지 되는 것이 보임
- 이는 서버에서 스크립트와 스타일만 포함된 HTML을 전송하기 때문
- 실제 렌더링은 클라이언트에서 이루어 짐
- CSR로 생성한 앱의 HTML을 보면 div태그 하나 밖에 없음, 그래서 빈화면만 보임
- 빌드 과정에서 js와 css파일을 HTML페이지에 불러오도록 만들고 root.div에 렌더링함

### CSR을 사용할 때의 주요 이점

- 네이티브 앱처럼 느껴지는 웹 앱
  - 전체 자바스크립트 번들을 다운로드 한다는 것은 렌더링할 모든 페이지가 이미 브라우저에 다운되어 있다는 뜻
  - 다른 페이지로 이동해도 서버에 요청할 필요 없이, 바로 페이지를 이동할 수 있음
  - 페이지를 바꾸기 위해 새로 고칠 필요 없음
- 쉬운 페이지 전환
  - 클라이언트에서의 내비게이션은 브라우저 화면을 새로 고칠 필요 없이 다른 페이지로 이동을 가능하게 만듬
  - 페이지 간 전환에 멋진 효과를 넣을 수도 있음. 애니메이션을 방해할 요소가 없기 때문
- 지연된 로딩과 성능
  - 웹 앱은 최소로 필요한 HTML만 렌더링함
  - 버튼을 누르면 나오는 모달도 실제 버튼이 눌렸을 때 동적으로 생성하게 됨
- 서버 부하 감소
  - 서버리스 환경에서 웹 앱을 제공할 수도 있음

### 장점은 단점이 될 수도 있다

- 네트워크 속도가 느린 환경에서는 번들이 모두 다운로드 될 때까지 계속 빈 페이지를 보아야 함
- 검색 로봇에게도 그 내용은 빈 것으로 보임
- 번들을 모두 받을 때까지 검색 로봇이 기다리기는 하지만 성능 점수는 낮을 것

- React,useEffect,Hook
- 최근 리액트는 함수형 컴포넌트 사용을 강조 하면서 life cycle함수 대신 Hook을 사용함

### 정적 사이트 생성(SSG: Static Site Generation)

- SSG는 일부 또는 전체 페이지를 빌드 시점에 미리 렌더링 함
- SSG는 SSR 및 CSR과 비교했을 때 다음과 같은 장점이 있음
  1. **쉬운 확장**
  - 정적 페이지는 단순 HTML 파일이므로 CDN을 통해 파일을 제공하거나, 캐시에 저장하기 쉬움
  2. **뛰어난 성능**
  - 빌드 시점에 HTML 페이지를 미리 렌더링하기 때문에 페이지를 요청해도 클라이언트나 서버가 무언가를 처리할 필여가 없음
  3. **더 안전한 API 요청**
  - 외부 API를 호출하거나, 데이터베이스에 접근하거나, 보호해야 할 데이터에 접근할 일이 없다. 필요한 모든 정보가 빌드 시점에 미리 페이지로 렌더링 되어 있기 때문
- SSG는 높은 확장성과 뛰어난 성능을 보이는 프론트엔드 애플리케이션을 만들고 싶을 때 가장 좋은 방법임
- 한 가지 문제점은 일단 웹 페이지를 만들고 나면 다음 배포 전까지 내용이 변하지 않는다는 것
- 조금이라도 수정하려면 필요한 데이터를 가져와서 수정하고 다시 생성하는 과정을 반복해야 함
- 이런 문제 때문에 나온 방법이 바로 "**증분 정적 재생성**(**ISR**: Incremental Static Regeneration)"이다.
- 예를 들어 동적 컨텐츠를 제공하지만 해당 컨텐츠 데이터를 로딩 하는데 시간이 오래 걸린다면, SSG와 ISR을 함께 사용하여 문제를 해결 할 수 있다.
- 많은 양의 데이터를 필요로 하는 복잡한 대시보드를 만든다면, 데이터를 불러 오기 위한 REST API호출에 수 초가 소요됨
- 만일 데이터가 자주 변하지 않는다면 SSG와 ISR을 사용해서 데이터를 10분동안 캐싱할 수 있다.

## 9월 04일 강의 내용

### 프로젝트의 기본 구조

- Next.js는 네비게이션을 구현할 때 react-router와 같은 라이브러리를 사용하지 않고, pages/ 디렉토리를 사용함
- pages/ 디렉토리 안의 모든 .js파일은 public 페이지가 됨
- pages/ 의 index.js파일을 복사해서, about.js로 이름을 바꾸면, http://localhost:3000/about 으로 접속할 수 있음
- public/ 디렉토리에는 웹 사이트의 모든 퍼블릭 페이지와 정적 콘텐츠가 있음
- styles/ 디렉토리에는 앱에서 사용하는 스타일시트를 넣음
- 용도가 정해져 있는 디렉토리는 pages/ 와 public/뿐임
- 나머지 디렉토리는 필요에 따라서 다른 목적으로 사용하거나 삭제해도 됨

### Next.js 14의 프로젝트의 기본 구조

- 프로젝트를 생성할 때 /src를 사용 여부를 선택할 수 있고, 일반적으로 사용함
- 14에서는 /public과 /src/app 디렉토리만 용도가 정해져 있음

### 타입스크립트 지원

- Next.js는 타입스크립트로 작성되었기 때문에 **고품질의 type definition**을 지원함
- 기본 언어를 타입스크립트로 지정하려면 root에 **tsconfig.json**이라는 설정파일 생성하면 됨

### 바벨과 웹팩 설정 커스터마이징

- 바벨이나 웹팩의 설정도 커스터마이징 할 수 있음
- 바벨은 **자바스크립트 트랜스컴파일러**이며, 최신 자바스크립트 코드를 **하위 호환성을 보장**하는 스크립트 코드로 변환하는 일을 담당함
- 하위 호환성이 보장되면 **어떤 웹 브라우저**에서든 자바스크립트 코드를 실행할 수 있음
- 바벨을 사용하면 브라우저나 Node.js 등에서 지원하지 않는 **새롭고 훌륭한 기능**을 현재의 환경에서도 실행 가능
- 바벨 설정을 커스터마이징 하려면, 프로젝트 Root에 **.babelrc** 라는 파일을 생성하면 됨
- 이 설정 파일을 비워 두면 오류거 발생하기 때문에 최소한 다음 내용을 저장해야 함

```js
{
  "presets":["next/babel"]
}
```

## 8월 28일 강의 내용

### Pages Router vs App Router

- React로 개발하다 처음 Next를 사용하면 제일 먼저 놀라는 기능이 Router다.
- 교재의 코드는 Next.js 13.1을 사용하기 때문에 Pages Router로 작성되고 있음
- 강의는 App Router로 진행할 예정임

#### [Pages Router]

- pages 디렉토리가 root이고, index.js가 index page가 됨
- about.js는 /about, team.js는 /team 경로로 라우팅 됨
- 클라이언트 중심의 라우팅이다.

#### [App Router]

- app 디렉토리가 root이고 pages.js가 index page가 됨
- /about/page.js는 /about, /login/page.js는 /page 경로로 라우팅 됨
- 서버 중심의 라우팅이다.
- 번들 사이즈가 작음

### Next.js 13 vs 14

- Pages Router -> App Router
- Date Fetching: 13까지는 getServerSideProps, getStaticProps 메소드를 이용해서 구현 했으나, 14에서는 SSG(정적 사이트 생성), SSR(서버측 렌더링) 및 ISR(증분적 정적 재생성)에서 하나의 API만을 사용해서 구현할 수 있게 됨
- Tubopack: Rust 기반으로 개발된 새로운 번들러 사용으로 webpack보다 700배 빠르다고 발표함
- 이미지 최적화: 13까지는 도구를 사용하였으나, 14부터는 자체적으로 지원하기 시작함
- 보안 강화: XSS 공격에 대한 보호 기능이 강화되고, 보안 관련 헤더 설정을 더욱 쉽게 만들었다.

### Next.js 알아보기

- Next.js는 리액트를 위해 만든 오픈소스 **자바스크립트 웹 프레임워크다.**
- 리액트에는 없는 **다양한 기능을 제공함**
  - 서버 사이드 렌더링(SSR)
  - 정적 사이트 생성(SSG)
  - 증분 정적 재생성(ISR)
    > **SSG(정적 페이지 생성)** 는 미리 만들어 놓은 페이지를 서비스 하기 때문에 **속도는 빠르지만**, 한번 생성하고 나면 **수정이 불가능**합니다.  
    >  이러한 단점을 보완하고자 나온 것이 **ISR(증분 정적 재생성)** 입니다.  
    >  **이미 생성된 페이지를 일정 시간이 지난 후에 다시 생성합니다.**(최신 데이터로 업데이트)
- [Chapter 1의 주요 내용]
  - Next.js 소개/ 다른 프레임워크와의 비교 / 리액트와의 차이점
  - 기본구조 타입스크립트를 사용하는 방법
  - 바벨과 웹팩 설정 커스텀마이징 (**Next.js14는 Webpack에서 Tubopack으로 바뀜**)

#### 1.1 준비하기

- Node.js와 npm을 설치하거나, codesandbox.io 혹은 repl.it 등의 사이트를 이용함.
- 이후 프로젝트별로 필요한 의존성 패키지를 npm욿 설치함
  - 잠시 확인을 위한 것이면 사이트를 이용해도 되지만, 그렇지 않은 경우라면 local에 환경을 설정하는 것이 좋다.

#### 1.2 Next.js가 제공하는 기능들

- 코드 분할(Splitting): 페이지를 로딩 할 떄 번들을 여러 조각으로 나누어 필요한 부분만 전송.
- 파일 기반 라우팅 (React에서는 React-RouterDom을 사용)
- 경로 기반 프리패칭(Prefetching): 사용자가 다음에 이동할 수 있는 페이지를 미리 가져오는 기술
- 이미지 최적화: Next/image 컴포넌트로 제공하는 이미지의 최적화 기술  
  (lazy loading- 지연, 이미지 사이즈 최적화- webp 변환, placeholder- 영역 확보)
- 웹 애플리케이션의 국제화 지원: 다국어 지원(local에 맞는 URL로 라우팅)

#### 1.3 Next.js와 비슷한 프레임워크

- **[Gatsby]**
  - 정적 웹 사이트를 만들 수 있는 프레임워크
  - 정적 사이트 생성만 지원
  - 클라이언트 사이드 렌더링만 지원함
  - 동적으로 변하는 복잡한 웹 사이트는 만들 수 없음
- **[Angular Universal]**
  - 정적 사이트 생성과 서버 사이드 렌더링을 지원함
  - Nuxt나 Next와는 달리 대기업인 구글에서 만듦
  - Angular로 개발하는 경우 Angular Universal을 사용하는 것이 대부분임

#### 1.4 왜 Next.js 일까?

- React에서 제공하지 않는 여러 기능을 지원함
- 설정이나 개발 옵션 등 다양한 부분에서도 유용한 기능들을 제공함
- 활동적인 커뮤니티가 있어 개발 단계별로 많은 지원을 받을 수 있다.

#### 1.5 리액트에서 Next.js로

- Next.js의 기본 철학은 React와 거의 같음
- "설정보다 관습"이라는 리액트의 철학을 계승  
  "CoC: Convention over Configuration"은 개발자가 해야 할 **결정의 수를 줄여**주면서도, **유연성은 잃지 않도록** 하는 소프트웨어 설계 패러다임이다.
- 예를 들면 설정 파일을 만들지 않고도 어떤 페이지에서 서버 사이드 렌더링을 적용하고, 어떤 페이지에 정적 페이지 생성을 적용할지 지정할 수 있음
- Next.js는 fetch, window, document와 같은 웹 브라우저에서 제공하는 전역 객체나 canvas같은 **HTML요소에는 접근 할 수가 없다.**
